using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace p00_Backend
{
    internal class Shared
    {
        public static int[] Data { get; set; } // store data values generated by producer thread
        public static int DataCount { get; set; } = 0; // total number fo values

        public static int BatchCount { get; set; }
        public static int BatchSize { get; set; }

        public static ManualResetEvent Event { get; set; }

        public static AutoResetEvent AutoEvent { get; set; }

        static Shared()
        {
            Data = new int[15];
            DataCount = Data.Length;
            BatchCount = 5;
            BatchSize = 3;
            Event = new ManualResetEvent(false); //unsignaled state
            AutoEvent = new AutoResetEvent(false);
        }
    }

    //Represents producter thread
    class Producer
    {
        public void Produce()
        {
            Console.WriteLine($"{Thread.CurrentThread.Name} has been started.");

            //generate some data and store it in the Data array
            for (int i = 0; i < Shared.BatchCount; i++) // 5 times
            {
                for (int j = 0; j < Shared.BatchSize; j++) // 3 times
                {
                    Shared.Data[i * Shared.BatchSize + j] = (i * Shared.BatchSize) + j + 1;
                    Thread.Sleep(300); //simulate some time-consuming operation
                }

                //set the signal (signal that the producer has finished generating data)
                Shared.Event.Set();
                //reset the signal (makes the consumer thread wait for signal before reading next batch)
                // comment line below if using AutoResetEvent
                // AutoResetEvent allows one waiting thread to proceed; and immediatly resets the event to "unsignaled". So an 
                // explicit reset is not required.
                Shared.Event.Reset(); //reset the event to unsignaled state for the next batch

            }
            

            //set the signal (signal that the producer has finished generating data)
            //Shared.Event.Set();

            Console.WriteLine($"{Thread.CurrentThread.Name} completed.");

        }
    }

    //Represents consumer thread
    class Consumer
    {
        public void Consume()
        {
            Console.WriteLine($"{Thread.CurrentThread.Name} has been started.");
            Console.WriteLine("Consumer is waiting for producer thread to finish generating data");

            for (int i = 0; i < Shared.BatchCount; i++)
            {
                Shared.Event.WaitOne(); //consumer thread waiths until the status of event becomes signaled (true)
                Console.WriteLine("Consumer has received a signal from the Producer");

                //read data
                Console.WriteLine("\nData is"); ;
                for (int j = 0; j < Shared.BatchSize; j++)
                {
                    Console.WriteLine(Shared.Data[i * Shared.BatchSize + j]);
                }

            }
            


            Console.WriteLine($"{Thread.CurrentThread.Name} completed.");

        }
    }

    class ThreadsDemo
    {
        public static void RunDemo()
        {
            //create objects of Producer and Consumer classes
            Producer producer = new Producer();
            Consumer consumer = new Consumer();

            //create delegate objects of ThreadStart
            ThreadStart threadStart1 = new ThreadStart(producer.Produce);
            ThreadStart threadStart2 = new ThreadStart(consumer.Consume);

            //create thread objects
            Thread producerThread = new Thread(threadStart1)
            {
                Name = "Producer Thread"
            };
            Thread consumerThread = new Thread(threadStart2)
            {
                Name = "Consumer Thread"
            };

            //start threads
            producerThread.Start();
            consumerThread.Start();

            //join both thread to main thread
            producerThread.Join();
            consumerThread.Join();

            Console.ReadKey();



        }
    }
}
